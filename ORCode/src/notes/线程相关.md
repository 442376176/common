## 线程池

### ThreadPoolExecutor

```java
 public ThreadPoolExecutor(int corePoolSize, // 1
                              int maximumPoolSize,  // 2
                              long keepAliveTime,  // 3
                              TimeUnit unit,  // 4
                              BlockingQueue<Runnable> workQueue, // 5
                              ThreadFactory threadFactory,  // 6
                              RejectedExecutionHandler handler ) { //7
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

参数解释：

<table>
    <tr>
    	<td>序号</td>
        <td>名称</td>
        <td>类型</td>
        <td>含义</td>
    </tr> 
    <tr>
    	<td>1</td>
        <td>corePoolSize</td>
        <td>int</td>
        <td>核心线程数</td>
    </tr> 
    <tr>
    	<td>2</td>
        <td>maximumPoolSize</td>
        <td>int</td>
        <td>最大线程池大小</td>
    </tr> 
    <tr>
    	<td>3</td>
        <td>keepAliveTime</td>
        <td>long</td>
        <td>线程最大空闲时间</td>
    </tr> 
    <tr>
    	<td>4</td>
        <td>unit</td>
        <td>TimeUnit</td>
        <td>时间单位</td>
    </tr> 
    <tr>
    	<td>5</td>
        <td>名称</td>
        <td>类型</td>
        <td>含义</td>
    </tr> 
    <tr>
    	<td>6</td>
        <td>workQueue</td>
        <td>BlockingQueue<Runnable></td>
        <td>线程等待队列</td>
    </tr>
    <tr>
    	<td>7</td>
        <td>threadFactory</td>
        <td>ThreadFactory</td>
        <td>线程创建工厂</td>
    </tr> 
   <tr>
    	<td>8</td>
        <td>handler</td>
        <td>RejectedExecutionHandler</td>
        <td>拒绝策略</td>
    </tr> 
</table>



### JDK预定义线程池

#### 	1.FixedThreadPool

```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
        0L, TimeUnit.MILLISECONDS,
      new LinkedBlockingQueue<Runnable>());
    }

corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；

keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；

workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；

FixedThreadPool的任务执行是无序的；
    
```

**适用场景**：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。

#### 	2.CachedThreadPool

```java
     public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
        60L, TimeUnit.SECONDS,
        new SynchronousQueue<Runnable>());
    }
corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即线程数量几乎无限制；
keepAliveTime = 60s，线程空闲60s后自动结束。
workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；
```

**适用场景**：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。

#### 	3.SingleThreadExecutor

```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
             0L, TimeUnit.MILLISECONDS,
             new LinkedBlockingQueue<Runnable>()));
    }

咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：
        public static void main(String[] args) {
        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(1);
        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;
        System.out.println(threadPoolExecutor.getMaximumPoolSize());
        threadPoolExecutor.setCorePoolSize(8);
        
        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();
//      运行时异常 java.lang.ClassCastException
//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;
    }
对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。

```

#### 	4.ScheduleThreadPool

```java
  
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。
ScheduledThreadPoolExecutor构造方法中最终调用的是父类ThreadPoolExecutor的构造方法；corePoolSize是传递进来的固定数值，maximumPoolSize的值是Integer.MAX_VALUE；DelayedWorkQueue是无界的，因此maximumPoolSize是无效的。

    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }


ScheduledThreadPool是一个能实现定时、周期性任务的线程池  

当执行ScheduledThreadPoolExecutor的scheduleAtFixedRate或scheduleWithFixedDelay方法，会向DelayedWorkQueue添加一个实现RunnableScheduledFuture接口的任务包装类ScheduledFutureTask，并检查运行的线程是否达到核心线程数corePoolSize。
如果没有就新建线程，并启动。但并非立即执行任务，而是去DelayedWorkQueue中取任务包装类ScheduledFutureTask，然后再去执行任务；
如果运行的线程达到了corePoolSize，就把任务添加到任务队列DelayedWorkQueue中；DelayedWorkQueue会将任务排序，先执行的任务放在队列的前面。
任务执行完后，ScheduledFutureTask中的变量time改为下次要执行的时间，并放回到DelayedWorkQueue中。

```



![image-20220223110712176](C:\Users\86151\Desktop\zcc\notes\pic\execute执行流程.png)

# JUC多线程及高并发



基本概念：

java.util.concurrent并发包的简称。这是一个处理线程的工具包，JDK1.5开始出现的。

进程和线程：

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。面向线程的设计中，进程是线程的容器。程序是指令、数据及其组织形式的面熟，进程是程序的实体。

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

线程的状态

#### 线程的状态枚举类

```java
public enum State {
    /**
     * Thread state for a thread which has not yet started.
     */
    NEW,新建

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE,就绪

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED,阻塞

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * <ul>
     *   <li>{@link Object#wait() Object.wait} with no timeout</li>
     *   <li>{@link #join() Thread.join} with no timeout</li>
     *   <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     *
     * <p>A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called <tt>Object.wait()</tt>
     * on an object is waiting for another thread to call
     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
     * that object. A thread that has called <tt>Thread.join()</tt>
     * is waiting for a specified thread to terminate.
     */
    WAITING,等待（不见不散）

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * <ul>
     *   <li>{@link #sleep Thread.sleep}</li>
     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
     *   <li>{@link #join(long) Thread.join} with timeout</li>
     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING,等待（过失不候）

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED;终结
}
```

### wait和sleep的区别

1）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。

2）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁（即代码要在synchronized中）

3）他们都可以被interrupted方法中断。

4）wait之后，需要notify唤醒

并发和并行：

串行模式：串行是一次只能取得一个任务，并执行这个任务

并行模式：并行是一次取得多个任务，并同时去执行所取得的这些任务。

并发：

同一时刻多个线程在访问同一个资源

多个线程对一个点

并发是：多项任务同一时刻执行

管程：Monitor 监视器 锁

是一种同步机制，保证同一时间，只有一个线程访问被保护资源

jvm同步基于进入和退出，使用管程对象实现的。

用户线程：

自定义线程

守护线程：特殊线程，运行在后台

比如垃圾回收

demo：

主线程结束，用户线程还在，JVM存活

没有用户线程，全是守护线程，JVM结束

```java
public static void main(String[] args) {
    new Thread(()->{
        System.out.println(Thread.currentThread().getName()+"::"+Thread.currentThread().isDaemon());
        while (true){

        }
    },"aa").start();
    
    System.out.println(Thread.currentThread().getName()+"::"+Thread.currentThread().isDaemon()+"执行结束");
}
```

```java
public static void main(String[] args) {
    Thread a = new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + "::" + Thread.currentThread().isDaemon());
        while (true) {

        }
    }, "aa");
    a.setDaemon(true);
    a.start();
    System.out.println(Thread.currentThread().getName() + "::" + Thread.currentThread().isDaemon() + "执行结束");
}
```





## Lock接口

### synchronized关键字

是java中重要的关键字，是一种同步锁。它修饰的对象有几种：

1.修饰代码块，被修饰的代码块成为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；

2.修饰一个方法，被修饰的方法成为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；

​	虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此synchronized关键字不能被继承。如果父类方法使用了synchronized，而子类覆盖了这个方法，在子类中的方法默认情况下不是同步的，必须显示的在子类的这个方法上加上synchronized关键字才可以。当然，还可以在子类方法调用父类中相应的方法，这样虽然子类的方法是不同步的，但子类调用了父类的同步方法，因此子类的方案也就是同步了。

3.修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；

4.修改一个类，起作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象

#### demo

```java
package com.zcc.JUC;



/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/1 16:53
 * @version:
 * @Describe:
 */
public class TicketDemo {

    public static void main(String[] args) {
        Ticket ticket = new Ticket();

        new Thread(()->{
            for (int i = 0; i < 20 ; i++) {
                ticket.subtract();
            }
        },"1").start();
        new Thread(()->{
            for (int i = 0; i < 20 ; i++) {
                ticket.subtract();
            }
        },"2").start();
        new Thread(()->{
            for (int i = 0; i < 20 ; i++) {
                ticket.subtract();
            }
        },"3").start();

    }

}

class Ticket{
    private int count = 30;

    /**
     * 买票
     */
    public synchronized void subtract(){
        if (count==0){
            System.out.println(Thread.currentThread().getName()+"票卖完了");
            return;
        }else {
            count--;
            System.out.println(Thread.currentThread().getName()+"卖出了1张票");
        }
    }
}
```

### Lock简介

lock锁实现提供了比使用同步方法/语句更广泛的锁操作。它允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。

#### 与synchronized区别

1.Lock不是java语言内置的，synchronized是关键字，因此是内置的。Lock是一个接口，通过这个接口的实现类可以实现同步访问。

2.采用synchronized不需要用户去手动释放锁，当代码执行到synchronized作用的范围结束后会自动让线程释放对锁的占用；而Lock则必须让用户去手动释放锁，如果没有释放，就有可能造成死锁现象；

3.Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；

4.通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。

5.Lock可以提高多个线程进行读操作的效率。

从性能上来说，如果竞争不激烈两者性能是差不多的，而当竞争资源非常激烈时，Lock性能远超synchronized。

### ReentrantLock 可重入锁



### 线程间通信

#### synchronized实现 demo

```java
package com.zcc.JUC;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/1 17:32
 * @version:
 * @Describe:线程通信使用synchronized完成demo
 */
public class CommunicateOfThread {

    public static void main(String[] args) {
        A a = new A();
        new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    a.increment();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "aa").start();
        new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    a.subtract();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "bb").start();
    }
}

class A {
    private int count = 0;

    synchronized void increment() throws InterruptedException {
        if (count != 0) {
            this.wait(); // 等待
        }
        count++; // 操作
        System.out.println(Thread.currentThread().getName() + "::" + count);
        this.notifyAll(); // 通知
    }

    synchronized void subtract() throws InterruptedException {
        if (count != 1) {
            this.wait();
        }
        count--;
        System.out.println(Thread.currentThread().getName() + "::" + count);
        this.notifyAll();
    }
}
```



#### 虚假唤醒问题

wait()方法特点：在哪里睡就会在哪里醒。可能存在虚假唤醒和实现中断，而且此方法应始终在循环中使用。

#### Lock实现demo

资源类

```
class B {
    private int count = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    void increment() throws InterruptedException {
        // 上锁
        lock.lock();
        try {
            while (count != 0) {
                // 等待
                condition.await();
            }
            count++; // 操作
            System.out.println(Thread.currentThread().getName() + "::" + count);
            condition.signalAll();
        } finally {
            // 解锁
            lock.unlock();
        }
    }

    void subtract() throws InterruptedException {
        lock.lock();
        try {
            while (count != 1) {
                condition.await();
            }
            count--; // 操作
            System.out.println(Thread.currentThread().getName() + "::" + count);
            condition.signalAll();
        } finally {
            lock.unlock();
        }

    }
}
```

测试

```java
@Test
public void testLock() {
    B b = new B();
    new Thread(() -> {
        try {
            for (int i = 0; i < 20; i++) {
                b.increment();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "aa").start();
    new Thread(() -> {
        try {
            for (int i = 0; i < 20; i++) {
                b.subtract();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "bb").start();
    new Thread(() -> {
        try {
            for (int i = 0; i < 20; i++) {
                b.increment();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "cc").start();
    new Thread(() -> {
        try {
            for (int i = 0; i < 20; i++) {
                b.subtract();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, "dd").start();
}
```



### 线程间的定制化通信

#### demo

需求：

​	启动三个线程，按照如下要求：

​		*AA打印5次 BB打印10次 CC打印15次

​		循环执行10次

代码：

```java
package com.zcc.JUC;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/2 10:21
 * @version:
 * @Describe:线程间定制化通信
 */
public class CommunicateOfThreadByCustomized {
    public static void main(String[] args) {
        ShareResource shareResource = new ShareResource();
        for (int i = 1; i <= 10; i++) {
            int finalI = i;
            new Thread(()->{
                shareResource.print5(finalI);
            },"aa").start();
            new Thread(()->{
                shareResource.print10(finalI);
            },"bb").start();
            new Thread(()->{
                shareResource.print15(finalI);
            },"cc").start();
        }
    }
}

class ShareResource {
    private int index = 1;
    private Lock lock = new ReentrantLock();

    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();

    /**
     * 打印五次
     *
     * @param loop 循环第几次
     */
    public void print5(int loop) {
        lock.lock();
        try {
            // 判断
            while (index != 1) {
                c1.await();
            }
            for (int i = 0; i < 5; i++) {
                System.out.println(Thread.currentThread().getName() + "::" + index + "第"+ loop+"波" );
            }
            // 修改标志位
            index++;
            // 通知
            c2.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 打印五次
     *
     * @param loop 循环第几次
     */
    public void print10(int loop) {
        lock.lock();
        try {
            // 判断
            while (index != 2) {
                c2.await();
            }
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + "::" + index + "第"+ loop+"波" );

            }
            // 修改标志位
            index++;
            // 通知
            c3.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    /**
     * 打印十五次
     *
     * @param loop 循环第几次
     */
    public void print15(int loop) {
        lock.lock();
        try {
            // 判断
            while (index != 3) {
                c3.await();
            }
            for (int i = 0; i < 15; i++) {
                System.out.println(Thread.currentThread().getName() + "::" + index + "第"+ loop+"波" );

            }
            // 修改标志位
            index = 1;
            // 通知
            c1.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
```



### 集合的线程安全

CopyOnWriteArrayList 写时复制技术 

1.并发读

2.独立写（

```java
CopyOnWriteArrayList add源码
public boolean add(E e) {
    // 可重入锁
        final ReentrantLock lock = this.lock;
    // 上锁
        lock.lock();
        try {
            // 获取原数组元素
            Object[] elements = getArray();
            // 获取原数组长度
            int len = elements.length;
            // 获取扩容1后的新数组
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            // 添加元素
            newElements[len] = e;
            // set新数组
            setArray(newElements);
            return true;
        } finally {
            // 解锁
            lock.unlock();
        }
    }
```

）

解决ArrayList线程不安全

```java
package com.zcc.JUC;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.thread
 * @author: zcc
 * @date: 2022/3/1 11:25
 * @version:
 * @Describe:集合类不安全问题
 */
public class ContainerNotSafeDemo {
    public static void main(String[] args) {
        // 一个空的数组 size为10
        List<String> list = new CopyOnWriteArrayList<>();
//        list.add("a");
//        list.add("b");
//        list.add("c");
//        list.forEach(System.out::println);
//        Collections.synchronizedList(new ArrayList<>());
        /**
         * 1 故障现象
         * java.util.ConcurrentModificationException
         * 多线程访问的常见异常 并发修改异常
         *
         * 2 导致原因
         *  并发争抢修改导致
         *  A正在写，B过来抢夺，导致数据不一致异常。并发修改异常
         *
         * 3 解决方案
         *  3.1 使用Vector 不推荐 性能差
         *  3.2 使用List<String> list = Collections.synchronizedList(new ArrayList<>()); 不推荐 性能差
         *  3.3 使用new CopyOnWriteArrayList<>()
         *
         * 4 优化建议
         *
         */
//       java.util.ConcurrentModificationException
        for (int i = 0; i < 30; i++) {
            new Thread(()->{
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            },String.valueOf(i)).start();
        }
    }
}
```

HashSet和HashMap线程不安全的演示及解决方案

CopyOnWriteSet

```java
CopyOnWriteSet add源码

public boolean add(E e) {
    return al.addIfAbsent(e);
}   
public boolean addIfAbsent(E e) {
    // 获取当前数组的快照
    Object[] snapshot = getArray();
    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :
        addIfAbsent(e, snapshot);
}
/**
* 用于判断是否存在添加的元素
*	o 添加的元素
*	elements 原数组
*	index 开始搜索的下标
*	fence 搜索结束的边界
*/
 private static int indexOf(Object o, Object[] elements,
                               int index, int fence) {
     // 遍历
        if (o == null) {
            for (int i = index; i < fence; i++)
                if (elements[i] == null)
                    return i;
        } else {
            for (int i = index; i < fence; i++)
                if (o.equals(elements[i]))
                    return i;
        }
        return -1;
    }

/**
*	e 添加元素
*	snapshot 当前调用线程获取到的主内存快照
*/
 private boolean addIfAbsent(E e, Object[] snapshot) {
        final ReentrantLock lock = this.lock;
     	// 上锁
        lock.lock();
        try {
            // 获取原数组
            Object[] current = getArray();
            // 获取原数组长度
            int len = current.length;
            // 两次获取不一致
            if (snapshot != current) {
                // Optimize for lost race to another addXXX operation
                int common = Math.min(snapshot.length, len);
                // 遍历判断情况
                for (int i = 0; i < common; i++)
                    // 已经存在于当前的数组，并且当前数据不一致（原数组被删减）
                    if (current[i] != snapshot[i] && eq(e, current[i]))
                        return false;
                // 已经存在于当前数组（且未被删减）
                if (indexOf(e, current, common, len) >= 0)
                        return false;
            }
            // 复制原数组长度+1的新数组
            Object[] newElements = Arrays.copyOf(current, len + 1);
            // 添加元素
            newElements[len] = e;
            // 重新set
            setArray(newElements);
            return true;
        } finally {
            // 解锁
            lock.unlock();
        }
    }
```

ConcurrentHashMap

```java
ConcurrentHashMap put源码

 transient volatile Node<K,V>[] table;（存值）
    
public V put(K key, V value) {
    return putVal(key, value, false);
}
final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        int hash = spread(key.hashCode());
        int binCount = 0;
    // 遍历原数组
        for (Node<K,V>[] tab = table;;) {
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                // 加锁 同步代
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        addCount(1L, binCount);
        return null;
    }
```





```java
        /**
         * HashSet
         *
         * 1.Collections.synchronizedSet(new HashSet<>());
         * 2.new CopyOnWriteArraySet<>();
         */
//        Set<String> strings = new HashSet<>();
//        Set<String> strings = new TreeSet<>();
//        Set<String> strings = Collections.synchronizedSet(new HashSet<>());
//        Set<String> strings = new LinkedHashSet<>();
//        Set<String> strings = new CopyOnWriteArraySet<>();
//        for (int i = 0; i < 30; i++) {
//            new Thread(() -> {
//                strings.add(UUID.randomUUID().toString().substring(0, 8));
//                System.out.println(strings);
//            }, String.valueOf(i)).start();
//        }

        /**
         * HashMap
         *
         * 1.new HashMap<>();
         * 2.Collections.synchronizedMap(new HashMap<>());
         * 3.new ConcurrentHashMap<>();
         *
         */
//        Map<String, String> stringStringHashMap = new HashMap<>();
//        Map<String, String> stringStringHashMap = new Hashtable<>();
//        Map<String, String> stringStringHashMap = Collections.synchronizedMap(new HashMap<>());
        Map<String, String> stringStringHashMap = new ConcurrentHashMap<>();
        for (int i = 0; i < 30; i++) {
            new Thread(() -> {
                stringStringHashMap.put(UUID.randomUUID().toString().substring(0, 8), "1");
                System.out.println(stringStringHashMap);
            }, String.valueOf(i)).start();
        }
    }
```



### synchronized加锁的8种情况

```java
package com.zcc.JUC;

import java.util.concurrent.TimeUnit;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/2 17:07
 * @version:
 * @Describe:
 * 1.标准访问，先打印短信还是邮件 短信
 * 2.停4秒在短信方法内，先打印短信还是邮件 短信
 * 3.新增普通的hello方法，是先打短信还是hello hello
 * 4.现在有两部手机，先打印短信还是邮件  邮件
 * 5.两个静态同步方法，1部手机，先打印短信还是邮件 短信
 * 6.两个静态同步方法，2部手机，先打印短信还是邮件 短信
 * 7.1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件   邮件
 * 8.1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件   邮件
 *
 * synchronized实现同步的基础：Java中的每一个对象都可以作为锁
 * 具体表现为3中形式：
 * 对于普通同步方法，锁是当前实例对象
 * 对于静态同步方法，锁是当前类的Class对象
 * 对于同步方法快，锁是synchronized括号里配置的对象
 */
public class Synchronized_lock_8 {
    public static void main(String[] args) {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();
        new Thread(()->{
            try {
                phone1.sendMSG();

            } catch (Exception e) {
                e.printStackTrace();
            }
        },"AA").start();

        new Thread(()->{
            try {
//                phone2.sendMail();
                phone1.sendMail();
            } catch (Exception e) {
                e.printStackTrace();
            }
        },"BB").start();
    }

}

class Phone {
    public static synchronized void sendMSG() throws Exception {
        TimeUnit.SECONDS.sleep(4);
        System.out.println("-----------------发送信息");
    }

    public synchronized void sendMail() throws Exception {
        System.out.println("-----------------发送邮件");
    }

    public void getHello() {
        System.out.println("-----------------getHello");
    }
}
```



### 公平锁和非公平锁

对比

非公平：线程饿死，效率高

公平：阳光普照，效率相对较低

### 可重入锁

synchronized（隐式）和Lock（显式）都是可重入锁



demo

```java
package com.zcc.JUC;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/4 9:22
 * @version:
 * @Describe: 可重入锁（递归锁）
 */
public class SynLockDemo {


    public synchronized void add(){
        add();
    }

    public static void main(String[] args) {
        // synchronized

        SynLockDemo synLockDemo = new SynLockDemo();
//        synLockDemo.add();

//        Object obj = new Object();
//        new Thread(() -> {
//            synchronized (obj) {
//                System.out.println(Thread.currentThread().getName() + "    外层");
//
//                synchronized (obj) {
//                    System.out.println(Thread.currentThread().getName() + "    中层");
//
//                    synchronized (obj) {
//                        System.out.println(Thread.currentThread().getName() + "    内层");
//                    }
//                }
//            }
//        }, "aa").start();

        // lock
        Lock lock = new ReentrantLock();

        new Thread(()->{
            lock.lock();
            try {
                System.out.println(Thread.currentThread().getName() + "    外层");
                lock.lock();
                try{
                    System.out.println(Thread.currentThread().getName() + "    中层");
                    lock.lock();
                    try{
                        System.out.println(Thread.currentThread().getName() + "    内层");
                        lock.lock();
                    }finally {
//                        lock.unlock();
                    }
                }finally {
//                    lock.unlock();
                }
            }finally {
                lock.unlock();
            }
        },"aa").start();
    }

}
```



### 死锁

#### 概述：

多个进程在执行过程中，因为争夺资源而造成的一种互相等待的现象，如果没有外力干涉，他们无法在执行下去。

#### 产生原因：

1.系统资源不足

2.进程运行推进顺序不合适

3.资源分配不当

**产生条件：**

虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件

**1）互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

**2）请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

**3）不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

**4）环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

**验证死锁:**

 jvm 自带堆栈跟踪工具

1)jps命令查看进程id

2)jstack命令查看是否是死锁

#### 解决：



### Callable接口

跟Runnable接口的区别：

CallAble的call（）有返回值并且可以抛出异常； Runnable的run（）无返回值且无法跑出异常

使用FutureTask配合创建线程。



### JUC强大的辅助类

#### 1.CountDownLatch 减少计数

该类可以设置一个计数器，然后通过countDown方法来进行-1操作，使用await方法等待计数器不大于0，然后继续执行await方法之后的语句

CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。

其他线程代用countDown方法会将计数器减1（调用countDown方法的线程不会阻塞）

当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。

#### demo

```java
package com.zcc.JUC;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/4 13:39
 * @version:
 * @Describe:
 */
public class CountDownLatchDemo {
    public static AtomicInteger count = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        // 创建CountDownLatch对象，设置初始值
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 0; i < 6; i++) {
            int finalI = i;
            new Thread(() -> {
//                count.compareAndSet(finalI-1 , finalI);
                countDownLatch.countDown();
                System.out.println(Thread.currentThread().getName() + "离开了教室" + countDownLatch.getCount());
//                System.out.println(Thread.currentThread().getName() + "离开了教室"+count.get());
            }, i + "").start();
        }


        countDownLatch.await();
        System.out.println("关门");

    }
}

class Student {
    public void leave() {
        System.out.println(Thread.currentThread().getName() + "离开了教室");
    }
}
```

#### 2.CyclicBarrier 循环栅栏

一个同步辅助类，他允许一组线程相互等待，知道到达某个公共屏障点（common barrier point）。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时CyclicBarrier很有用。因为该barrier在释放等待线程后可以重用，所以称它为循环的barrier

CyclicBarrier支持一个可选的Runnable命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。



大致可以理解为循环阻塞，在使用中CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier理解为加一操作。



#### 3.Semaphore 信号灯

一个技术信号量。从概念上讲，信号量维护了一个许可集。如果有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可。每个acquire添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行技术，并采取相应的行动。

Semaphore通常用于限制可以访问某些资源（物理或逻辑）的线程数目。



```java
package com.zcc.JUC;

import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * @ProjectName: ORCode
 * @ClassName: com.zcc.JUC
 * @author: zcc
 * @date: 2022/3/4 16:19
 * @version:
 * @Describe:6辆汽车，停三个车位
 */
public class SemaphoreDemo {

    public static void main(String[] args) {
        // 创建Semaphore，设置许可数量
        Semaphore semaphore = new Semaphore(3);
        // 模拟6辆汽车
        for (int i = 1; i <= 6; i++) {
            int finalI = i;
            new Thread(()->{
                try {
                    // 抢占
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"抢到了车位");
                    // 设置随机停车时间
                    TimeUnit.SECONDS.sleep(new Random().nextInt(10));
                    System.out.println(Thread.currentThread().getName()+"离开了车位");

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    //释放
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }
    }
}
```

结果

```shell
1抢到了车位
2抢到了车位
3抢到了车位
1离开了车位
4抢到了车位
3离开了车位
2离开了车位
6抢到了车位
5抢到了车位
6离开了车位
5离开了车位
4离开了车位
```



### 读写锁

#### 悲观锁：

操作数据直接加锁；好处：能解决并发中的各种问题；缺点：不支持并发操作，效率较低。

![image-20220304163858430](C:\Users\86151\Desktop\zcc\notes\pic\悲观锁.png)

#### 乐观锁：

支持并发。乐观锁操作数据的时候会添加一个version 版本号，每次事务提交之后都会修改数据并且修改版本号。每次提交之前都会拿当前事务中的版本号和数据库的版本号做对比，一致则修改，不一致则提交失败。

![image-20220304164026831](C:\Users\86151\Desktop\zcc\notes\pic\乐观锁.png)

#### 数据库表锁和行锁

根据加锁的范围，MySQL里面的锁大致可以分为全局锁、表级锁、行锁；

1. **全局锁**

  加全局锁命令：flush table with read lock;（FTWRL）

  `mysql> flush table with read lock;`

  释放全局锁命令：unlock tables;

  `mysql> unlock tables;`

2. **全局锁的特点**

  全局锁让整个数据库（所有表）处于只读状态，使用这个命令后，数据库表的增删改（DML）、表结构的更改（DDL）、更新类事物的提交都会被阻塞；

例如下面，前面我已经给该数据库加上了全局锁，此时对其中一个表进行查询和插入操作：

`mysql> select * from test;`

`2 rows in set (0.00 sec)`

`mysql> insert into test values('yyg','zhongxian');`
`ERROR 1223 (HY000): Can't execute the query because you have a conflicting read lock`
可以看到，查询是允许的，而插入是禁止的；

2. **全局锁的作用（全库逻辑备份）**
上面看到了全局锁会让数据库只处于可读的状态，这种状态会使数据库处于一个多么低效率的状态，那么为什么还需要它呢？

低效率的原因：

如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；
如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟；
因为在以前，全局锁的主要作用就是：做全库逻辑备份；
即在备份的时候，加上全局锁，让表只处于可读状态，处于这种

那么为什么这么做呢？即为什么需要在备份的时候加全局锁呢，这里用反证法来证明：

**案例：**假如一个商城里有两张表，一张用户所购商品表，一张是用户余额表，假如在备份商品表刚完成还没开始备份用户余额表的时候，一位用户购买了某个产品，此时它的余额扣除成功，然后备份了用户余额表，这时造成的现象就是：备份的商品表没有用户买的那个商品，但备份的余额表却扣除了钱；

假如是备份完余额表，用户下单，再备份商品表的话，结果就是：用户的余额没扣，却多了商品；

上面的案例说明了，在做全库逻辑备份的时候，如果不加锁，会造成备份得到的库里面的表不是一个逻辑时间点 ，这个视图是逻辑不一致的；那么提到这，对于视图一致性，事物的可重复读这个隔离性不就能够实现吗；所以官方自带逻辑备份工具是mysqldump。当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事物，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的；

那么，有了mysqldump这个功能，为什么还需要FTWRL？（⭐）
因为mysqldump是基于事物的，而有些引擎不支持事物，比如MyISAM，这种引擎在做全库逻辑备份的时候就只能使用全局锁了；

对于全库只读，还有一种方式可以实现：

`set global readonly = true`

那么到底使用set的方式还是使用FTWRL的方式来进行全库逻辑备份呢？这里有两个原因推荐使用FTWRL：

1.在有些系统里，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库，因此修改global变量的影响比较大，不建议使用；
2.两者在异常处理机制上有差异：
执行FTWRL命令之后由于客户端的发生异常断开，那么MySQL会自动释放这个全局锁，整个库可以回到正常更新的状态；
执行set global这个方式的话，如果客户端发生异常，则数据库还是一直会保持只读状态，这样会导致整个库长时间处于不可写状态，风险较高；

2. **表级锁**
MySQL里面表级别的锁分两种：

表锁
元数据锁（mete data lock，MDL）
1. **表锁**
    加锁命令： lock tables 表名 read/write

  `mysql> lock table test read;`

  释放锁的命令：unlock tables；

2. **特点**
    当还没有出现更细粒度的锁时，表锁是常用的处理并发问题的方式，而对于InnoDB这种支持行锁的引擎，一般不适用表锁，因为表锁的影响效率还是很大；

对某个表加表锁锁，不仅影响其他线程对该表的对应操作，也会影响当前线程对这张表的操作，例如：

`mysql> lock table test read;`

`mysql> insert into test(name,adress) values('ygz','zhongxian');`
`ERROR 1099 (HY000): Table 'test' was locked with a READ lock and can't be updated`

上面表示了对该表加读锁后，自己也不能对其进行修改；自己和其他线程只能读取该表；

当对某个表执加上写锁后（lock table t1 write），该线程可以对这个表进行读写，其他线程对该表的读和写都受到阻塞； （⭐）
例子：启动一个命令行（线程）连接数据库，对test表进行加上写锁，然后在该线程中执行读和写：

`mysql> insert into test(name,adress) values('zsf','zhongxian');`
`Query OK, 1 row affected (0.64 sec)`

`mysql> select * from test;`
`+----+------+-----------+`
`| id | name | adress    |`
`+----+------+-----------+`
`|  1 | yy   | ChongQing |`
`|  2 | lch  | XiAn      |`
`|  3 | yyg  | zhongxian |`
`|  4 | ygz  | zhongxian |`
`|  5 | zsf  | zhongxian |`
`+----+------+-----------+`
`5 rows in set (0.00 sec)`

然后启动另外一个线程（重新打开一个cmd连接该数据库），然后执行查询test表，如下，回车后将会阻塞于此，处于无结果状态（ctrol+c可以撤销）：

`mysql> select * from test;`


当在第一个线程中执行unlock tables后（即释放这个写锁），第二个线程的查询马上就有了结果；
同样，在第二个线程中对该表的更新也是一样的效果；

2. **MDL元数据锁（metadata lock）**
1. **特点**
MDL是在MySQL5.5中引入的，MDL不需要显示的使用，在访问一个表的时候会自动加上，它的作用是保证读写的正确性；
当对一个表做增删查改的时候，加MDL读锁，当对表结构做更改操作的时候，加MDL写锁；
读锁之间不互斥，所以可以多个线程同时对一张表增删查改；
读写锁之间，写锁之间是互斥的，如果有多个线程要同时给一个表加字段，其中一个要等待另外一个执行完成才能开始执行；
事物中的MDL锁，在语句执行时开始申请，，但是语句结束后并不会马上释放，而是等到这个事物提交后才释放； （⭐）
MDL锁作用：（例子）

假如一个线程正在遍历一个表，在此期间另一个线程对这个表的结构做了变更，比如加了个字段，那么遍历查询的线程拿到的结果跟表结构对不上，这肯定是不行的；

3. **MDL锁的坑————给一个小表加字段**
1. **问题描述**
这里将讲述关于给一个小表加字段的注意事项，曾经有人因为这导致了整个库挂掉；

如上图，事物A先开启，这时会对表t加一个MDL读锁，由于事物B需要的也是MDL读锁，因此可以正常执行；
但此时事物C需要更改表的结构，则需要获取MDL写锁，但此时事物A的读锁还没有释放，所以事物C就会被阻塞，事物C一阻塞，就算后面需要的是MDL读锁，也都会被阻塞，这将可能会导致后面的所有事物都不能对这个表进行增删改查，如果这个表上的查询语句很频繁，而且客户端有重试机制，这将会导致这个数据库线程很快就会爆满；

注意：事物中的MDL锁，在语句执行时开始申请，，但是语句结束后并不会马上释放，而是等到这个事物提交后才释放； （⭐）
为验证这一点，我们来做个实验，开启一个cmd连接数据库，然后开启一个事物（A），执行查询test表的操作，然后开启另一个cmd链接数据库，开启新的事物（B），此时在后面的事物中执行alter表test的操作，会发现阻塞在那；
事物A：

`mysql> start transaction;`
`Query OK, 0 rows affected (0.00 sec)`

`mysql> select * from test;`
`+----+------+-----------+`
`| id | name | adress    |`
`+----+------+-----------+`
`|  1 | yy   | ChongQing |`
`|  2 | lch  | XiAn      |`
`|  3 | yyg  | zhongxian |`
`|  4 | ygz  | zhongxian |`
`|  5 | zsf  | zhongxian |`
`+----+------+-----------+`
`5 rows in set (0.09 sec)`

事物B:

`mysql> use java7;`
`Database changed`
`mysql> start transaction;`
`Query OK, 0 rows affected (0.00 sec)`

`mysql> select * from test;`
`+----+------+-----------+`
`| id | name | adress    |`
`+----+------+-----------+`
`|  1 | yy   | ChongQing |`
`|  2 | lch  | XiAn      |`
`|  3 | yyg  | zhongxian |`
`|  4 | ygz  | zhongxian |`
`|  5 | zsf  | zhongxian |`
`+----+------+-----------+`
`5 rows in set (0.00 sec)`

`mysql> alter table test add sex char;`


发现阻塞于此。。。。

此时将事物A中的事物提交，这边马上就修改成功了；
事物B：（会发现修改表结构成功）

`mysql> alter table test add sex char;`
`Query OK, 0 rows affected (7 min 38.42 sec)`
`Records: 0  Duplicates: 0  Warnings: 0`

2. **解决方法**
从上面的案例可以看到，假如事物A尽早的提交，也就不会造成阻塞的连锁反应，所以要解决上面的问题，首先要解决长事物； 事物一直不提交，就会一直占着MDL锁；

要查看当前有哪些事物正在执行，可以进入MySQL的information_schema库，查看其中的innodb_trx表；
如果你要做DDL变更的表正好有长事物在执行，你就考虑先暂停DDL，或者kill掉这个长事物；

新问题：
如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求又很频繁，而你又不得不加个字段，这时候该怎么做呢？

这时候kill掉就未必有用了，因为新的请求又会马上到来，所以这时比较理想的机制是，在alter table语句里面设定等待时间，如果在这个指定时间内能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃进行表结构更改；之后开发人员或者DBA再通过重试命令重复这个过程；

MariaDB已经合并了AliSQL这个功能，所以这两个开源分支都支持 DDL NOWAIT/WAIT N 这个语法；

`alter table test nowait drop sex;`
`alter table test wait n drop sex;`

3. **online ddl（ddl：更改表结构）**
在MySQL5.6支持online ddl，这是什么意思呢，下面来看看online ddl的步骤：

拿MDL写锁
降级成MDL读锁
真正做DDL
升级成MDL写锁
释放MDL锁
对于上面的案例，是不是用online ddl就不会出现那样的情况了呢？
答案是：还会出现那样的情况，因为上面的案例是我们在第一步就阻塞了，也就是根本还没有拿到MDL写锁呢，要等事物一提交了才能拿到，所以阻塞于此，online ddl做到的优化只是在真正拿到MDL写锁后，可以让读也能同时进行 ；

3. **行锁**
行锁是在引擎层由各个引擎自己实现的，有的引擎并不支持行锁，比如MyISAM就不支持行锁，这意味着：

并发控制只能使用表锁，对于这种引擎（MyISAM）的表，同一张表上任何时刻只能有一个更新在执行，这严重影响了并发度；
InnoDB是支持行锁的，这也是MyISAM被InnoDB代替的主要原因；

1. **行锁特性**
首先注意：InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则都会从行锁升级为表锁； （⭐）

下面来看一个例子：
开启两个cdm窗口，启动两个事物A、B，在事物A中更改表中的一行数据，此时未提交事物A，再在事物B中查询该表，会发现查询的结果是A未修改的结果，也就是事物A还没提交，它对表test的更新对B不可见；

事物A：

`mysql> start transaction;`
`Query OK, 0 rows affected (0.00 sec)`

`mysql> update test set name='WangWu' where id=1;`
`Query OK, 1 row affected (0.04 sec)`
`Rows matched: 1  Changed: 1  Warnings: 0`

事物B：（可以看到还是原来的数据）

`mysql> select * from test;`
`+----+---------+-----------+`
`| id | name    | adress    |`
`+----+---------+-----------+`
`|  1 | zangsan | ChongQing |`
`|  2 | lch     | XiAn      |`
`|  3 | yyg     | zhongxian |`
`|  4 | ygz     | zhongxian |`
`|  5 | zsf     | zhongxian |`
`+----+---------+-----------+`
`5 rows in set (0.02 sec)`

此时再做一个实验，（事物A还未提交），在事物B中更改其他行，看是否能成功：

`mysql> update test set name='LiSi' where id=2;`
`Query OK, 1 row affected (0.11 sec)`
`Rows matched: 1  Changed: 1  Warnings: 0`

`mysql> select * from test;`
`+----+---------+-----------+`
`| id | name    | adress    |`
`+----+---------+-----------+`
`|  1 | zangsan | ChongQing |`
`|  2 | LiSi    | XiAn      |`
`|  3 | yyg     | zhongxian |`
`|  4 | ygz     | zhongxian |`
`|  5 | zsf     | zhongxian |`
`+----+---------+-----------+`
`5 rows in set (0.00 sec)`

`mysql> update test set name='LiSi' where id=1;`
`ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction`


可以看到，在事物A未提交的情况下：

B中不能更新A中更新的那一行（会受到阻塞，一定时间如果还没获取到行锁会自动放弃更新），其他行都能更新；
当A一提交，B中更新A中更新的那一行就会不再阻塞，执行完毕；
为验证行锁是建立在索引之上的，我们在在事物A中不用id更新test表，如下：
（id是主键，所以是有索引的）

`mysql> start transaction;`
`Query OK, 0 rows affected (0.00 sec)`

`mysql> update test set name='TaoLiu' where name='ygz';`
`Query OK, 1 row affected (0.02 sec)`
`Rows matched: 1  Changed: 1  Warnings: 0`

此时在事物B中更新另外一行：

`mysql> update test set name='ZangLiu' where id=2;`

发现阻塞于此，没有更新同一行啊，为什么会被锁住？
因为这里事物A中的更新没有基于索引（name没加索引），所以这里由行锁会降级成表锁，所以在事物B中不能对该表进行任何更新，只能读；

2. **两阶段锁协议**
在InnoDB事物中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事物提交了才会释放，这个就是两阶段锁协议；

知道了这个协议后，对我们的某些开发会得到效率提升，比如：

如果你的事物中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放；
4. **死锁**
死锁这个名词相信大家都不陌生，同样数据库也会有死锁的出现，这里举一个例子（以行锁导致的死锁为例）：

如上图，当执行完事物B的update最后一句时，回车出现如下：

`ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction`

1. **处理死锁策略**
（1）：直接进入等待，直到超时，这个超时时间可以通过参数innodb_lock_wait_timeout来进行设置，如下：（InnoDB中查看这个参数默认是50秒）

`mysql> show variables like 'innodb_lock_wait_timeout';`
`+--------------------------+-------+`
`| Variable_name            | Value |`
`+--------------------------+-------+`
`| innodb_lock_wait_timeout | 50    |`
`+--------------------------+-------+`
`1 row in set, 1 warning (0.00 sec)`

设置的话，语句是：

`mysql> set innodb_lock_wait_timeout = 50;`
`Query OK, 0 rows affected (0.00 sec)`

（2）发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事物，让其他事物得以执行；
将参数innodb_deadlock_detect设置为on，就代表开启； （InnoDB默认开启死锁检测）

`mysql> show variables like 'innodb_deadlock_detect';`
`+------------------------+-------+`
`| Variable_name          | Value |`
`+------------------------+-------+`
`| innodb_deadlock_detect | ON    |`
`+------------------------+-------+`
`1 row in set, 1 warning (0.04 sec)`

设置语句为：

`mysql> set global innodb_deadlock_detect = on;`
`Query OK, 0 rows affected (0.05 sec)`

两种方案区别：

第一种等待50s，这显然对于在线服务起来说是等不起的，时间设置太短又会造成误判；
所以一般采用第二种：死锁检测，InnoDB本身默认就是将那个参数设置为on的，但这种方式也是有弊端的，毕竟死锁检测需要消耗资源，具体详细下面来讲；

2. **死锁检测**（⭐）
上面讲了，死锁检测是数据库检验死锁的一个策略，检测所需要的代价就是：

每当一个事物被锁住的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，即死锁；
进行死锁检测的条件：

当前事物需要加锁访问的行上被别人锁住时，才会进行死锁检测
注意点：

一致性读的时候不会加锁，所以不用死锁检测
并不是每次死锁检测都要扫描所有的事物，比如下面这种情况：
B在等A
D在等C
现在事物E来了，发现E需要等D，则此时E需要判断跟D、C是否成环（形成死锁），并不会去检测B和A，因为他们访问的肯定不是同一个资源；
3. **典型案例**（CPU利用率高，但效率低的场景）
那么假如出现这样一个场景：
一千个事物要同时更新test表中的同一行数据，这时其实并不会发生死锁，但会发现效率极低，这是为什么呢？
因为每一个被（行锁）堵住的线程都会去判断是不是由于自己的加入导致了死锁，这是一个时间复杂度为O（n）的操作，一千个事物，此时时间复杂度高达100万这个数量级，虽然最终检测没有死锁，但是期间消耗了大量的CPU资源，所以你将会看到，CPU利用率很高，但是却执行不了几个事物；

那么怎么解决上面这种问题呢？

（1）如果你确认你的操作中不会出现死锁，就关闭死锁检测；当然这种方法风险是很大的，毕竟死锁的出现不是我们能预估的，一旦出现，就会造成超时等待；
（2）控制并发度；
在上面的例子中，是同时有大量线程去更新同一行导致的，假如把并发度降到很低就不会出现时间复杂度过大的死锁检测了，具体做法就是对于更新相同行数据的线程，在进入引擎前排队，这样在InnoDB里面就不会同时有大量的死锁检测工作了；

#### 读锁

共享锁

![image-20220307090646260](C:\Users\86151\Desktop\zcc\notes\pic\读锁发生死锁.png)

1线程修改的时候需要等待2线程读之后

2线程修改的时候需要等待1线程读之后

#### 写锁

独占锁



![image-20220307091007619](C:\Users\86151\Desktop\zcc\notes\pic\写锁死锁.png)





1写完之后要写2操作的部分，2写完之后要写1操作的部分

都会发生死锁；



读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时存在读和写的线程，读写互斥，读读共享，写写互斥的

![image-20220307100759968](C:\Users\86151\Desktop\zcc\notes\pic\读写锁的演变.png)

1.造成锁饥饿，一直读，没有写操作。

2.读时候，不能进行写操作，（写操作可以读）

#### 锁降级

将写入锁降级为读锁

jdk8说明：

![image-20220307101203772](C:\Users\86151\Desktop\zcc\notes\pic\锁降级.png)

1.获取写锁

2.获取读锁

3.释放写锁

4.释放读锁

锁降级：

锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。

 

锁降级的必要性：

锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁， 假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。

这里要着重讲一讲“无法感知”是什么意思：

也就是说，在另一个线程（假设叫线程1）修改数据的那一个瞬间，当前线程（线程2）是不知道数据此时已经变化了，但是并不意味着之后线程2使用的数据就是旧的数据，相反线程2使用还是被线程1更新之后的数据。也就是说，就算我不使用锁降级，程序的运行结果也是正确的（这是因为锁的机制和volatile关键字相似）。

那么为什么还要锁降级呢，其实目的是为了减少线程的阻塞唤醒。明显当不使用锁降级，线程2修改数据时，线程1自然要被阻塞，而使用锁降级时则不会。“感知”其实是想强调读的实时连续性，但是却容易让人误导为强调数据操作。

**读锁不能升级为写锁**



## CAS

### 介绍使用

全程是Compare-And-Swap 它是一条CPU并发原语。

它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。

CAS并发原语体现在JAVA语言汇总就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题。



compareAndSet		比较并交换

compareAndSet（Integer expect ，Integer update）

expect 期望值

update 更新值



```java
  AtomicInteger atomicInteger = new AtomicInteger(5);
        System.out.println(atomicInteger.compareAndSet(5, 2019)+"\t current data: "+atomicInteger.get());
        System.out.println(atomicInteger.compareAndSet(5, 1024)+"\t current data: "+atomicInteger.get());


打印结果：
    Connected to the target VM, address: '127.0.0.1:52254', transport: 'socket'
true	 current data: 2019
false	 current data: 2019
Disconnected from the target VM, address: '127.0.0.1:52254', transport: 'socket'

Process finished with exit code 0
```

### 底层原理

自旋锁+unsafe类



源码分析

```java
getAndIncrement()方法
    解决了i++在多线程的线程
    
        public final int getAndIncrement() {
        return unsafe.getAndAddInt(this, valueOffset, 1);
    }
this 当前对象
valueoffset 内存偏移量  即内存地址
```

#### 1.unsafe

是CAS的核心类，由于Java方法无法直接访问底层系统，需要本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。

注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。

#### 2.变量valueOffset

该变量值表示内存中的偏移地址，因为Unsafe就是根据内存偏地址获取数据的

```java
/**
 * Atomically increments by one the current value.
 *
 * @return the previous value
 */
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```

#### 3.变量value

该变量用volatile修饰，保证了多线程之间的内存可见性。



```java
/**
* var1 操作对象
* var2 内存地址
* var4 1
*/
public final int getAndAddInt(Object var1, long var2, int var4) {
    // 当前对象的value
    int var5;
    do {
        // 拷贝主物理内存上的值到当前线程内 
        var5 = this.getIntVolatile(var1, var2);
        // 比较并交换 如果v1的值和v5相等 则v5加1
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
compareAndSwapInt（）方法返回布尔值
    比较并交换 
    如果v1的值和v5相等 则更新对象值为v5+v4 返回true
    否则 返回false
```

### JMM

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（又称栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量拷贝副本，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![image-20220228160017257](C:\Users\86151\Desktop\zcc\notes\pic\JMM简要图.png)



### CAS缺点

#### 1.循环时间长 内存开销大

如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。

#### 2.只能保证一个共享变量的原子操作



#### 3.引出来ABA问题

​	狸猫换太子

demo：

CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差类会导致数据的变化。

线程A从内存读取一个共享变量x = 5，线程B从内存读取共享变量x = 5，线程B操作x更新为10，由于A操作较慢，线程B多次操作更新x，最后在线程A执行getAndCompareSwapInt方法之前B线程又把x更新为5，A线程通过CAS成功将x更新为10。

尽管线程A的操作是成功的，但并不代表这个过程是没有问题的

#### 4.如何解决ABA问题

原子引用 + 新增一种机制，那就是修改版本号（类似时间戳）

AtomicReference<T>





